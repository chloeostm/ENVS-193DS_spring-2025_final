---
title: "ENVS 139DS Final"
author: "Chloe Ostermann"
date: "2025-06-8"
format: 
  html: 
    toc: true
    toc-float: true
    toc-location: left
---

GitHub link: https://github.com/chloeostm/ENVS-193DS_spring-2025_final.git

```{r libraries}
#| message: false
# Read in packages
library(tidyverse)
library(janitor)
library(here)
library(dplyr)
library(tibble)
library(gt)
library(readxl)
library(ggeffects)
library(MuMIn) 
library(DHARMa)
```

# Problem 1. Research Writing

## a.

In part 1, they used Pearson's correlation. In part 2 they used an ANOVA test

## b.

To improve their data communication, my co-worker could include an effect size statistic to communicate how large the calculated differences are between groups. For instance, they could determine how large the difference in means of nitrogen load is between sources which adds valuable insight on the significance of the results.
Additionally, they could include a Post-hoc pairwise comparison such as a Tukey's HSD comparison to improve how they communicated the results of the ANOVA test. This would help determine which specific group differs from the others. For instance, whether the average nitrogen load in waste water treatment differs significantly from fertilizer treatment. 

## c.



#Problem 2. Data Visualization

## a.

```{r}

sst <- read_csv(here("data","SST_update2023.csv")) # read in data from data folder using here()
sst_clean <- sst %>% # use raw sst data
  clean_names() # clean names of data so there's no spaces between words

sst_clean$year <- as.numeric( # converts year into a numeric value
  format(as.Date(sst_clean$date), "%Y")) # extracts year from date and makes it a Date object
sst_clean$year <- factor(sst_clean$year, levels = 2018:2023) # make year a factor with 6 levels
sst_clean$month <- as.numeric(format(as.Date(sst_clean$date), "%m")) # extract month
sst_clean$month <- factor(sst_clean$month,levels = 1:12, # factorize month with 12 levels
                          labels = month.abb,ordered = TRUE) # abbreviate and order months
sst_clean$date <- NULL # remove date column
sst_clean <- sst_clean %>% # altering sst-clean data
  filter(!is.na(year)) # remove rows where year shows NA

sst_clean_summary <- sst_clean %>% # summarizing sst_clean data
  group_by(year, month) %>% # grouping by year and month
  summarise(
    mean_monthly_sst = round(mean(temp, na.rm = TRUE),1), # calculate mean temperature and round to nearest tenth
    .groups = "drop" # un-groups tibble
  )
str(sst_clean_summary) # show structure of sst_clean_summary
sst_clean_summary %>% # use sst_clean_summary data
  slice_sample(n = 5) # display tibble with 5 random rows

```

## b.

```{r}

#| warning: false

#create custom colors to define a green color gradient in the correct order
green_shades <- c("2018" = "#c3f6c3", "2019" = "#a1d99b", 
                  "2020" = "#74c476", "2021" = "#31a354", 
                  "2022" = "#006d2c", "2023" = "#00441b") 

ggplot(data = sst_clean_summary, # create table from sst_clean_summary data
       aes(x = month, # set x axis data
           y = mean_monthly_sst, # set y axis data
           color = year)) + # show different colors for different years
  geom_point() + # create points for each data point
  geom_line(aes(group = year)) + # create lines connecting data points from each year
  scale_y_continuous( 
    breaks = seq(14, 20, by = 2), # Ensure 20 is included as top tick
    limits = c(12, 20), # Set axis limits to cap at 20
    expand = expansion(mult = c(0, 0)) # Prevent extra padding
  ) +
  
  scale_color_manual(values = green_shades) +
  labs(title = "Sea Surface Temperature in SB channel", # set title
       x = "Month", # name x axis
       y = "Mean monthly sea surface temperature (ºC)", # name y axis
       color = "Year") + # name legend "water year"
  
  theme(
    panel.grid = element_blank(), # remove grid
    panel.background = element_rect(fill = "white", color = NA), 
    # color background white
    plot.background = element_rect(fill = "white", color = NA), 
    # color plot white
    panel.border = element_rect(color = "darkgrey", fill = NA, size = 1),
    legend.position = c(0.10, 0.70), # position legend inside the panel
    plot.title = element_text(hjust = -0.1) # move the title
)
```

#Problem 3. Data Analysis

```{r}

nest_boxes <- read.csv(here("data","occdist.csv"))
nest_boxes_clean <- nest_boxes %>% 
  clean_names()

```

## a.

In this data set, a 1 indicates that the associated bird species was present in the nest box. A 0 indicates that the nest box was unoccupied by that bird species.

## b.

In this experiment, the difference between these birds is that Swift Parrots are the target critically endangered bird species, whereas the Common Starlings and Tree Martins are non target native competitors to the Swift Parrots and have been recorded to inhabit the nest boxes intended for the Swift Parrots.

## c.

The authors refer to two "seasons" which are two different years of study, 2016 and 2019, in which they recorded during the breeding season of the Swift Parrot species. The difference between these seasons is that the nest boxes were more established and familiar to the target and non-target species in 2019 compared to 2016 when they were freshly deployed resulting in stronger nest to bird relationships in 2019. 

## d. 

| Model number | Season | Distance to forest edge | Model Description           |  
|:------------:|:------:|:-----------------------:|:----------------------------|  
| 1            |        |                         | no predictors (null model)  |
| 2            |   X    |            X            | all predictors (full model) | 
| 3            |        |                         | SLA and water treatment     |   
| 4            |        |                         | SLA and species             |    

## e. 

```{r}

# model 1: null model
model1 <- lm(
  sp ~ 1, # formula
  data = nest_boxes_clean # data frame
)

# model 2: all predictors
model2 <- lm(
  sp ~ season + edge_distance, # formula
  data = nest_boxes_clean # data frame
)

# model 3: season
model3 <- lm(
  sp ~ season, # formula
  data = nest_boxes_clean # data frame
)

# model 4: edge_distance
model4 <- lm(
  sp ~ edge_distance, # formula
  data = nest_boxes_clean # data frame
)

```
## f. 

```{r}

plot(simulateResiduals(model0))
plot(simulateResiduals(model1))
plot(simulateResiduals(model2))
plot(simulateResiduals(model3))

```


## g.

```{r}

model_compare <- AIC(model1, model2, model3, model4)
model_compare <- model_compare[order(model_compare$AIC), ]
print(model_compare)

```

The best model as determined by Akaike’s Information Criterion (AIC) that predicts Swift Parrot nest box occupancy includes season and edge distance.

## h.

```{r}



ggplot(nest_boxes_clean,
       aes(x = edge_distance, y = sp, color = season)) +
  geom_jitter(width = 8, height = 0.05, alpha = 0.5) +

  # Model prediction lines
  stat_smooth(method = "glm",
              methods.args = list(family = "binomial"),
              se = TRUE,
              fullrange = TRUE,
              aes(fill = season)) +
  scale_y_continuous(name = "Probability of Swift Parrot Nest Box being occupied",
                     limits = c(0, 1)) +
  scale_x_continuous(name = "Distance from Forest edge (m)") +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    text = element_text(size = 12)
  )

  # Axis labels
  labs(
    x = "Distance to Forest Edge (m)",
    y = "Probability of Nest Box Occupancy",
    title = "Model Predictions of Nest Box Occupancy by Distance and Season",
    color = "Season",
    fill = "Season"
  ) 
  
```
```{r}
ggplot(nest_boxes_clean, aes(x = interaction(season, sp), y = edge_distance)) +
  
  # Boxplot with fill by occupancy
  geom_boxplot(aes(fill = factor(sp)),
               alpha = 0.5,
               outlier.shape = NA) +

  # Jittered points overlaid on boxplots
  geom_jitter(aes(color = factor(sp)),
              width = 0.2,
              size = 2,
              alpha = 0.8) +
  facet_wrap(~ season, nrow = 1) +

  # Custom axis labels (season on x, not the full interaction term)
  #scale_x_discrete(labels = function(x) gsub("\\.0", " (No)", gsub("\\.1", " (Yes)", x))) +

  # Labels and colors
  labs(
    x = "Breeding Season and Nest Occupancy",
    y = "Distance to Forest Edge (m)",
    fill = "Nest Occupied",
    color = "Nest Occupied",
    title = "Swift Parrot Nest Occupancy by Season and Distance to Forest Edge"
  ) +

  scale_fill_manual(values = c("0" = "#D55E00", "1" = "#0072B2"),
                    labels = c("No", "Yes")) +
  scale_color_manual(values = c("0" = "#D55E00", "1" = "#0072B2"),
                     labels = c("No", "Yes")) +

  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    text = element_text(size = 12)
  )
```



```{r model-predictions}
model2_preds <- ggpredict(
  model2, # model object
  terms = c("edge_distance [all]", "season") # predictors
) %>% 
  rename(season = group,
         edge_distance = x)
  # treating this like a regular data frame
  # renaming the columns
nest_boxes_clean$season <- as.factor(nest_boxes_clean$season)

ggplot() +
  geom_point(data = nest_boxes_clean,
       aes(x = edge_distance,
           y = as.numeric(sp),
           color = season),
       size = 3,
       alpha = 0.4,
       position = position_jitter(height = 0.00)) +
  geom_ribbon(data = model2_preds,
              aes(x = edge_distance,
                  ymin = conf.low,
                  ymax = conf.high,
                  fill = season),
              alpha = 0.3) + 
  geom_line(data = model2_preds,
            aes(x = edge_distance,
                y = predicted,
                color = season),
            linewidth = 1) +
  scale_y_continuous("Swift Parrot Occupancy: Yes (1) or No (0)",
                     limits = c(0, 1),
                     breaks = seq(0, 1)) +
  scale_color_discrete(name = "Season") +
  scale_fill_discrete(name = "Season") +
  labs(x = "Distance from Forest Edge (m)") +
  theme_minimal(base_size = 14)

```



#Problem 4. Affective and exploratory Visualization

## a. 

These two visualizations differ since the affective visualization heavily leans on artistic elements and creativity to share data whereas the exploratory visualizations I made for Homework 2 were designed to explicitly share the quantitative data in a simple and straightforward graph without any artistic embellishments.

One similarity that I see is that in both visualizations I opted to communicate the actual data using box plots. I also separated each of the variables in my exploratory visualizations using distinct colors which I also did for my affective one.

I found different patterns in my data for both visualizations mainly because I had collected much more data points by the time I made the affective visualization which resulted in different trends and patterns. For instance, my exploratory visualizations suggested that I slept more on average on days where I took the bus instead of walking, whereas my affective visualization indicated that I slept the most on days where I walked.
The range of my data boxplots was also larger for my affective visualization since it had more data and thus a broader range since it had more outliers recorded.

During our Week 9 workshop, I received positive feedback on my drawing design and choice of colors. My classmates suggested that I incorporate more elements alluding to the sleep variable I was using in my data, which I integrated into my design by making my little sleeping figurines in the box plots larger and gave them elements such as a pillow and a sleeping mask.


